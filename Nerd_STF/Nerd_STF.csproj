<Project Sdk="Microsoft.NET.Sdk">

  <!-- General stuff -->
  
  <PropertyGroup>
    <TargetFrameworks>netstandard1.1;netstandard1.3;netstandard2.1;net46;net462;net47;netcoreapp3.0;net5.0;net7.0</TargetFrameworks>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <ProduceReferenceAssembly>True</ProduceReferenceAssembly>
    <DebugType>portable</DebugType>
    <GeneratePackageOnBuild>True</GeneratePackageOnBuild>
    <CheckNotRecommendedTargetFramework>false</CheckNotRecommendedTargetFramework>
  </PropertyGroup>
  
  <!-- NuGet package customization. -->
  
  <PropertyGroup>
    <Title>Nerd_STF</Title>
    <Version>3.1.0</Version>
    <Authors>That_One_Nerd</Authors>
    <Description>A general-purpose mathematics library for C#.</Description>
    <PackageProjectUrl>https://github.com/That-One-Nerd/Nerd_STF</PackageProjectUrl>
    <PackageIcon>Logo Square.png</PackageIcon>
    <PackageReadmeFile>README.md</PackageReadmeFile>
    <RepositoryUrl>https://github.com/That-One-Nerd/Nerd_STF</RepositoryUrl>
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
    <IncludeSymbols>True</IncludeSymbols>
    <SymbolPackageFormat>snupkg</SymbolPackageFormat>
    <PackageTags>c#;csharp;c sharp;math;mathematics;mathametics;maths;color;rgb;rgba;cmyk;cmyka;hsv;hsva;calculus;linear algebra;linalg;linearalgebra;matrix;matrix2x2;matrix 2x2;matrix3x3;matrix 3x3;matrix4x4;matrix 4x4;matrix multiplication;vector;vector2d;vector3d;vector2;vector3;float2;float3;float4;int2;int3;int4;angle;geometry;vert;line;polygon;triangle;quadrilateral;sphere;circle;number system;numbersystem;complex numbers;complex;2d numbers;2dnumbers;quaternions;4d numbers;4dnumbers;equation;equations;polynomial;quadratic;linear equation;discrete mathematics;discrete math;set notation;relation;discrete;ycbcr;ypbpr;ycc</PackageTags>
    
    <!-- Sorry this is stupidly long, wish I could have linked a markdown file instead. -->
    <PackageReleaseNotes># Nerd_STF v3.1

Hi! It's been a while, but I've got a few things for you guys.

## More color configurations.

I've been spending a lot of my time recently working on [a Java library for FRC light strips](https://github.com/That-One-Nerd/betterlights) and in the process I made a tool for gradients. I ended up finding myself wishing I had it in here, too, so I've added it.

It functions mostly as a list of colors and associated positions for those colors. You can add and remove colors over time, and you index it (or call `.Get()`) with a value between 0 and 1 to determine a color. For example:

```csharp
Gradient&lt;ColorRGB&gt; gradient = new()
{
    { 0.0, ColorRGB.Red },
    { 0.5, ColorRGB.Green },
    { 1.0, ColorRGB.Blue },
};

Console.WriteLine(gradient[0.2].HexCode()); // #996600
```

You can also quickly and easily visualize your gradients right in the console, so long as your console has compatibility for RGB colors.

```
Console.WriteLine("Our gradient: " + gradient.ToColorString());
```
produces this in the terminal:
&lt;img width="590" height="38" alt="image" src="https://github.com/user-attachments/assets/692b9263-a4f6-4a18-97af-71e9ce830f34" /&gt;
&lt;sub&gt;Note that the resulting preview is actually a 1668 character string behind the scenes.&lt;/sub&gt;

You can change the way the colors interpolate, if you'd like. Simply set `gradient.Interpolation` to any function that takes two colors and a float, and outputs a color.

```csharp
Gradient&lt;ColorRGB&gt; gradient = new()
{
    { 0.0, ColorRGB.Red },
    { 0.5, ColorRGB.Green },
    { 1.0, ColorRGB.Blue },
};

// Interpolate through white. Don't look at the implementation too
// much, the point is to demonstrate that it can be set to whatever.
gradient.Interpolation = (a, b, t) =&gt;
{
    ColorRGB c;
    if (t &lt;= 0.5) (c, t) = (a, t * 2);
    else (c, t) = (b, -2 * t + 2);
    return (t, t, t) + c * (1 - t);
};
Console.WriteLine("        Through White: " + gradient.ToColorString() + "\n");

// Or you can set it to some simple templates.
gradient.Interpolation = Gradient&lt;ColorRGB&gt;.Nearest;
Console.WriteLine("     Nearest Neighbor: " + gradient.ToColorString() + "\n");

gradient.Interpolation = Gradient&lt;ColorRGB&gt;.Lerp;
Console.WriteLine("Default Interpolation: " + gradient.ToColorString() + "\n");
```

For the result:
&lt;img width="666" height="105" alt="image" src="https://github.com/user-attachments/assets/96c17685-5817-4d70-bdb9-241cb6735309" /&gt;

### `ColorYCC`

In addition, I have also implemented the YC&lt;sub&gt;b&lt;/sub&gt;C&lt;sub&gt;r&lt;/sub&gt; color space in the `ColorYCC` class. [YCbCr](https://en.wikipedia.org/wiki/YCbCr) is a way to convert RGB colors into a luminance value and two chrominance values. The conversion relies on the constants K&lt;sub&gt;r&lt;/sub&gt;, K&lt;sub&gt;g&lt;/sub&gt;, and K&lt;sub&gt;b&lt;/sub&gt;, which can be statically modified in the class. The constants are set to what I'm fairly certain is the most common standard, but the conversion system works for any $K_r + K_g + K_b = 1$.

## `Validatable&lt;T&gt;`

A small object I created mostly for the purposes of RGB &lt;-&gt; YCC conversion. It's done using matrix and vector multiplication, so I've cached the matrices required. However, if the K constants ever got changed, the matrix and its inverse needed to be recomputed. This is the purpose of the `Validatable` class.

When constructed, a method must be passed that "generates" a valid value when requested.
`Validatable&lt;int&gt; obj = new(() -&gt; ...);`

Afterwards, when `obj.Value` is read, the object either runs the generation function and caches the result, or returns an already cached result.

To force the object to re-generate a value, simply declare it invalidated by `obj.Invalidate()`. This will cause the generator to be re-invoked *only when required*. It's essentially a re-usable version of `System.Lazy&lt;T&gt;`.

## Discrete Math

I took discrete math last semester and decided to implement some of the things we discussed in that class here. Namely, the `Nerd_STF.Mathematics.Discrete` namespace contains mathematically-defined sets and relations. I think I went a little overboard with the abstraction here, I may use a better system in the future. But the important types to note are the `DiscreteSet&lt;T&gt;` and `DiscreteRelation&lt;T1, T2&gt;` types. The `DiscreteSet` contains a unique set of elements of type `T`, and a relation is a mapping of one set to another. Here's an example.

```csharp
DiscreteSet&lt;int&gt; evens = [], odds = [], primes = [];
for (int i = 0; i &lt; 20; i++)
{
    if (i % 2 == 0) evens += i;
    else odds += i;

    if (IsPrime(i)) primes += i;
}
Console.WriteLine($"Evens set: {evens}\nOdds set: {odds}\nPrimes set: {primes}");

DiscreteRelation&lt;int, int&gt; relation = new();
foreach (int odd in odds)
{
    if (odd == 1) continue;
    foreach (int even in evens)
    {
        if (even % (odd - 1) == 0) relation += (even, odd);
    }
}
Console.WriteLine("\nRelation between evens and odds:\n" + relation);
```

Yields:
&lt;img width="1083" height="158" alt="image" src="https://github.com/user-attachments/assets/028d1c09-6074-420f-9c34-71c93eaf9348" /&gt;

Some things were handled better than others. The source code of the `DiscreteRelation` class specifically is a scuffed mess of long type names and abstraction, and none of this is particularly fast or efficient, but it works for simple situations and isn't too abstraction-heavy on the part of the user of this library.

## Some final thoughts.

I may in the future condense `DiscreteRelation&lt;T1, T2&gt;` into a single type parameter for both the input and output. It makes things like the relation matrix and symmetry detection easier to implement.

I don't think I'm done with graphics. I've got some more ideas in the pipeline, but this library obviously takes a while to work on.

I also have a ton of very small tweaks I want to make. Things such as clamping color values in the constructors, or getting rid of `SplitArray` because the `System.Linq` namespace basically does that in a more modular way. Some small patches may be in order, but releasing this is such a pain I like to do it in bulk.

---

Take care, and enjoy 3.1!</PackageReleaseNotes>
  </PropertyGroup>

  <!-- ItemGroup customization based on framework. -->
  <!-- Mostly used to reference system packages that are not included in this version of .NET Standard. -->
  <!-- TODO: Maybe this isn't good practice, and we should define environment variables for specific features (tuples, drawing, etc) instead? -->

  <ItemGroup Condition="'$(TargetFramework)'=='netstandard1.1'">
    <PackageReference Include="System.Drawing.Primitives" Version="4.3.0" />
    <PackageReference Include="System.Net.Http" Version="4.3.4" />                <!-- Version that comes with .NET has vulnerabilities. -->
    <PackageReference Include="System.Memory" Version="4.5.5" />                  <!-- Newer versions not supported. -->
    <PackageReference Include="System.Numerics.Vectors" Version="4.5.0" />        <!-- Newer versions not supported. -->
    <PackageReference Include="System.Text.RegularExpressions" Version="4.3.1" /> <!-- Version that comes with .NET has vulnerabilities. -->
    <PackageReference Include="System.ValueTuple" Version="4.5.0" />              <!-- Newer version not supported. -->
  </ItemGroup>
  
  <ItemGroup Condition="'$(TargetFramework)'=='netstandard1.3'">
    <PackageReference Include="System.Drawing.Primitives" Version="4.3.0" />
    <PackageReference Include="System.Net.Http" Version="4.3.4" />                <!-- Version that comes with .NET has vulnerabilities. -->
    <PackageReference Include="System.Memory" Version="4.5.5" />                  <!-- Newer versions not supported. -->
    <PackageReference Include="System.Numerics.Vectors" Version="4.5.0" />        <!-- Newer versions not supported. -->
    <PackageReference Include="System.Text.RegularExpressions" Version="4.3.1" /> <!-- Version that comes with .NET has vulnerabilities. -->
    <PackageReference Include="System.ValueTuple" Version="4.5.0" />              <!-- Newer version not supported. -->
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)'=='net46'">
    <PackageReference Include="System.Memory" Version="4.5.5" />                  <!-- Newer versions not supported. -->
    <PackageReference Include="System.ValueTuple" Version="4.5.0" />              <!-- Newer versions not supported. -->
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)'=='net462'">
    <PackageReference Include="System.Memory" Version="4.6.2" />
    <PackageReference Include="System.ValueTuple" Version="4.6.1" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)'=='net47'">
    <PackageReference Include="System.Memory" Version="4.6.2" />
  </ItemGroup>
  
  <!-- PropertyGroup customization based on framework. -->
  <!-- Used to define environment variables based on features the framework supports. -->

  <PropertyGroup Condition="'$(TargetFramework)'=='netstandard1.1'">
    <DefineConstants>$(DefineConstants);CS7_OR_GREATER</DefineConstants>
  </PropertyGroup>

  <PropertyGroup Condition="'$(TargetFramework)'=='netstandard1.3'">
    <DefineConstants>$(DefineConstants);CS7_OR_GREATER</DefineConstants>
  </PropertyGroup>

  <PropertyGroup Condition="'$(TargetFramework)'=='netstandard2.1'">
    <DefineConstants>$(DefineConstants);CS7_OR_GREATER;CS8_OR_GREATER</DefineConstants>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <PropertyGroup Condition="'$(TargetFramework)'=='net46'">
    <DefineConstants>$(DefineConstants);CS7_OR_GREATER</DefineConstants>
  </PropertyGroup>

  <PropertyGroup Condition="'$(TargetFramework)'=='net462'">
    <DefineConstants>$(DefineConstants);CS7_OR_GREATER</DefineConstants>
  </PropertyGroup>

  <PropertyGroup Condition="'$(TargetFramework)'=='net47'">
    <DefineConstants>$(DefineConstants);CS7_OR_GREATER</DefineConstants>
  </PropertyGroup>

  <PropertyGroup Condition="'$(TargetFramework)'=='netcoreapp3.0'">
    <DefineConstants>$(DefineConstants);CS7_OR_GREATER;CS8_OR_GREATER</DefineConstants>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <PropertyGroup Condition="'$(TargetFramework)'=='net5.0'">
    <DefineConstants>$(DefineConstants);CS7_OR_GREATER;CS8_OR_GREATER;CS9_OR_GREATER</DefineConstants>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <PropertyGroup Condition="'$(TargetFramework)'=='net7.0'">
    <DefineConstants>$(DefineConstants);CS7_OR_GREATER;CS8_OR_GREATER;CS9_OR_GREATER;CS10_OR_GREATER;CS11_OR_GREATER</DefineConstants>
    <Nullable>enable</Nullable>
  </PropertyGroup>
  
  <!-- Pack extra stuff into the NuGet package. -->

  <ItemGroup>
    <None Include="..\Extras\Logo Square.png">
      <Pack>True</Pack>
      <PackagePath>\</PackagePath>
    </None>
    <None Include="..\README.md">
      <Pack>True</Pack>
      <PackagePath>\</PackagePath>
    </None>
    <None Include="..\Changelog.md">
      <Pack>True</Pack>
      <PackagePath>\</PackagePath>
    </None>
    <None Include="..\LICENSE.md">
      <Pack>True</Pack>
      <PackagePath>\</PackagePath>
    </None>
  </ItemGroup>

</Project>
